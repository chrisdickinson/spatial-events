{
  "name": "domnode",
  "description": "node style streams for the DOM",
  "version": "0.0.3",
  "repository": {
    "type": "git",
    "url": "git://github.com/maxogden/dominode.git"
  },
  "keywords": [
    "templating",
    "dom",
    "stream",
    "mvc",
    "framework",
    "pipe"
  ],
  "dependencies": {
    "mustache": "0.4.0"
  },
  "license": "MIT",
  "author": {
    "name": "Max Ogden",
    "email": "max@maxogden.com",
    "url": "http://maxogden.com"
  },
  "readme": "# dominode - node's evented API for HTML5\n# dominode - node point browser\n# dominode - node style streams for DOM nodes\n\n**still alpha/work in progress**\n\nyou want to learn node's core APIs but you're stuck on the client side? no problemo! dominode uses javascript _verbatim and unchanged_ directly from node to give you a way to elegantly stream data into your web app.\n\n## philosophy\n\nnode.js describes itself as a framework for dealing with \"evented i/o\" and traditionally runs on the server. clients, however, are just a i/o bound as servers (ajax requests, file uploads, indexeddb/websql, etc.) and can benefit from the nice APIs that node has developed to solve these problems in a server environment.\n\ndominode uses a few key javascript libraries from node ([Stream](http://nodejs.org/api/stream.html), [Util](http://nodejs.org/api/util.html), etc via [browserify](https://github.com/substack/node-browserify)) and adds some new syntax for dealing with the DOM.\n\nthe major goal of this library is to avoid reinventing the wheel when it comes to problems that are done well in node but aren't done well in most client side javascript libraries. since dominode uses node's source code verbatim you get to use the [node documentation](http://nodejs.org/api/) as well as the multitude of [node modules](http://search.npmjs.org) and related information floating around on the internets to look up how these things work\n\n## description\n\nnode Stream instances are basically unix pipes. they can be readable, writable or both. they are easy to reason about -- you can pipe a readable stream to a writable stream by doing `readableStream.pipe(writableStream)`.\n\nreadable streams will `emit` (emit is observer pattern - a publish/subscribe pattern which allows a number of observer objects to see an event) `data` events each time they get a \"chunk\" of data and then they will emit `end` when they are all finished. different types of streams will have different ways of chunking up their data. for example, a library that reads CSVs might emit `data` every time it reads a new line whereas an AJAX request might emit `data` every few kilobytes during the download.\n\nthe idea behind dominode is to hook up various I/O sources that are commonly used in client side development to the Stream API. for example say you have a JSON API that returns data like this:\n\n    {\"toppings\": [\"mushrooms\", \"pineapples\", \"canadian bacon\"]}\n\nyou could implement a Stream that will `emit` once for every topping and pipe that stream to a dominode instance that knows how to render JSON data into the DOM using an HTML template\n\ncurrently dominode is using the [mustache](https://github.com/janl/mustache.js) templating library which lets you bind JSON data to HTML, but it's easy to override mustache and hook up your own client side templater\n\n## example\n\n    // pass in the selector location where the dominode will get rendered and the template it will use for each data event\n    var list = dominode('.list', '<div id=\"number\"></div>')\n    \n    // pipe some data to your dominode\n    var readStream = new stream.Stream()\n    readStream.readable = true\n    readStream.pipe(list)\n    readStream.write = function (data) {\n      this.emit('data', data); return true\n    }\n    readStream.end = function (data) {\n      this.emit('end')\n    }\n    // adds <div id=\"number\">1</div>,\n    //      <div id=\"number\">2</div>\n    //  and <div id=\"number\">3</div>\n    /    to <div class=\"list\"></div>\n    readStream.write({number: 1})\n    readStream.write({number: 2})\n    readStream.write({number: 3})\n\n## browserify usage\n\n`browserify -r events -r buffer -r stream -r util -r mustache -o bundle.js`\n\n## roadmap\n\n - implement common stream wrappers:\n   - XHR (naive implementation [here](https://github.com/maxogden/streaming-xhr-example/blob/master/attachments/streaming-xhr.js#L78))\n   - websockets (done already by @dominictarr as [BrowserStream](https://github.com/dominictarr/browser-stream))\n   - indexeddb/pouchdb\n   - FileReader (implemented [here](https://github.com/wookiehangover/dominode-filestream))\n   - webworkers\n   - webRTC\n   - mouse/touch events\n   - setInterval\n - examples using a few different templating libraries\n - examples using MVVM style \"cascading dominodes\" (the pun is strong with this one)\n\nMIT LICENSE\n",
  "readmeFilename": "readme.md",
  "_id": "domnode@0.0.3",
  "_from": "domnode@~0.0.3"
}
